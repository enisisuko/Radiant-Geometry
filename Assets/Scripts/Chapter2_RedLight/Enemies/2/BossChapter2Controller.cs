// AUTO-GENERATED BY ChatGPT (RE:Dream) on 2025-09-28
// BossChapter2Controller.cs — Chapter 2 Boss (Enhanced)
// Changes in this edition:
//   1) Dark Sprite wave gating: never spawn a new wave until previous wave is fully eliminated.
//   2) Phase 1 adds two flashy skills:
//        • Homing Laser (uninterruptible, ground-blocked, drains Red energy)
//        • Scythe Sweep Laser (wide-angle rotating beam, drains Red energy, ground VFX)
//   3) Phase 2 specials expanded to five total by adding:
//        • Homing Laser Chase (longer/meaner tracking beam)
//        • Scythe Sweep II (faster/wider sweep)
//   4) Laser utilities implemented with LineRenderer-based runtime beams (no extra code deps).
//      If you have LaserBeamSegment2D prefab, you can swap to it easily (see TODO notes).
//
// Asset notes you may want to provide (optional but recommended):
//   • laserHitGroundVfx : small spark/smoke VFX for ground impact (looping is okay).
//   • laserMaterial     : URP Unlit material for the beam (or leave null to auto-create).
//
// -----------------------------------------------------------------------------

using FadedDreams.Enemies;             // DarkSpriteAI
using FadedDreams.Player;              // RedLightController
using FadedDreams.World.Light;         // Torch / BossTorchLink
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.Rendering.Universal;
using UnityEngine.SceneManagement;
// 显式别名避免命名冲突（如果你的项目里有）
using CamShake = FadedDreams.CameraFX.CameraShake2D;

namespace FadedDreams.Bosses
{
    [DisallowMultipleComponent]
    [RequireComponent(typeof(Rigidbody2D))]
    public class BossChapter2Controller : MonoBehaviour, IDamageable
    {
        // ================== 引用 ==================
        [Header("Refs")]
        public Transform player;
        public Rigidbody2D rb;
        public SpriteRenderer model;
        public Light2D auraLight;

        [Tooltip("分身外观预制（仅视觉+颤抖，不可交互）")]
        public BossC2Clone clonePrefab;

        [Tooltip("会扣红条的Boss专用子弹")]
        public BossRedDrainBullet bulletPrefab;

        [Tooltip("震爆弹（可用你已有 ShockwaveGrenade）")]
        public ShockwaveGrenade grenadePrefab;

        [Tooltip("黑暗精灵预制（2~4个）")]
        public DarkSpriteAI darkSpritePrefab;

        [Tooltip("死亡爆炸特效（VFX 可选）")]
        public GameObject deathVfxPrefab;

        [Tooltip("全屏爆炸VFX（可选）")]
        public GameObject bigExplosionVfx;

        // ========== 阶段点位 & 火炬 ==========
        [Header("Phase 1 ― Drop Points & Torches (4个点位)")]
        public Transform[] phase1DropPoints = new Transform[4];
        public BossTorchLink[] phase1Torches = new BossTorchLink[4];

        [Header("Phase 2 ― Dash Points & Torches (4个新点位)")]
        public Transform[] phase2DashPoints = new Transform[4];
        public BossTorchLink[] phase2Torches = new BossTorchLink[4];

        // ========== 进度设定 ==========
        [Header("Progress / Hits")]
        public int phase1HitsToAdvance = 3;
        public int phase2HitsToKill = 3;

        // ========== 一阶段：空中攻击循环 ==========
        [Header("Phase 1 ― Airborne Attacks")]
        public Vector2 attackIntervalRange = new Vector2(1.2f, 1.8f);
        public float bigBulletSpeed = 10f;
        public float bigBulletRedDamage = 20f;
        public int bigBulletVolley = 5;
        public float grenadeSpeed = 7f;

        // ========== 新增：激光技能（两阶段通用参数） ==========
        [Header("Laser Skills (Common)")]
        [Tooltip("用于检测地面遮挡的层（Ground/World）")]
        public LayerMask groundMask;
        [Tooltip("玩家检测层（应与 Player 层一致）")]
        public LayerMask playerLayer;
        [Tooltip("激光材质（URP/Unlit）。若为空将临时创建一个。")]
        public Material laserMaterial;
        [Tooltip("激光击中地面时的VFX（可循环的火花/烟雾）")]
        public GameObject laserHitGroundVfx;

        // Phase 1 lasers
        [Header("Laser — Phase 1")]
        public Color laserColorP1 = new Color(1f, 0.3f, 0.2f, 1f);
        public float laserWidthP1 = 0.12f;
        [Tooltip("追踪激光：持续时长")]
        public float homingLaserDurationP1 = 2.6f;
        [Tooltip("追踪激光：每秒扣除的红能量")]
        public float homingLaserDrainPerSecP1 = 35f;
        [Tooltip("追踪激光：每秒最大转向角度（度）")]
        public float homingLaserTurnRateDegP1 = 240f;
        [Tooltip("旋镰扫射：横扫角度（度）")]
        public float scytheSweepSpanDegP1 = 120f;
        [Tooltip("旋镰扫射：扫射持续时间（秒）")]
        public float scytheSweepSecondsP1 = 1.5f;
        [Tooltip("旋镰扫射：每秒扣除红能量")]
        public float scytheSweepDrainPerSecP1 = 22f;

        // Phase 2 lasers
        [Header("Laser — Phase 2")]
        public Color laserColorP2 = new Color(1f, 0.5f, 0.35f, 1f);
        public float laserWidthP2 = 0.14f;
        public float homingLaserDurationP2 = 3.25f;
        public float homingLaserDrainPerSecP2 = 45f;
        public float homingLaserTurnRateDegP2 = 280f;
        public float scytheSweepSpanDegP2 = 160f;
        public float scytheSweepSecondsP2 = 1.35f;
        public float scytheSweepDrainPerSecP2 = 28f;

        [Header("Laser Misc")]
        [Tooltip("计算激光最大长度（无穷时的近似值）。")]
        public float laserMaxDistance = 1200f;
        [Tooltip("逐帧对击中玩家的能量扣除，将乘以Time.deltaTime。")]
        public bool laserContinuousDrain = true;
        [Tooltip("激光淡出时长（s）")]
        public float laserFadeOutSeconds = 0.25f;

        // ========== 索敌 ==========
        [Header("Aggro / Detect")]
        public bool useDetectRadius = true;
        public float detectRadius = 20f;
        public bool startAggroImmediately = false;    // 仅在 useDetectRadius=false 时有效
        private bool _aggro = false;

        // ===== 玩家解析过滤 & 检测安全 =====
        [Header("Player Resolve Filters")]
        public string playerTag = "Player";
        public bool requireTagForResolve = true;
        public bool requireLayerForResolve = false;

        [Header("Detect — Safety & Debug")]
        public bool usePhysicsCircleCheck = true;
        public bool debugLog = false;
        public bool debugDetectSpam = false;
        public float debugDetectSpamInterval = 0.5f;

        private Collider2D _playerCol;
        private readonly Collider2D[] _hits = new Collider2D[16];
        private float _nextSpamTime;
        private Collider2D _lastDetectHit;
        private string _lastDetectWhy;

        // ========== 火炬窗口 ==========
        [Header("Torch Window")]
        public float torchWindowSeconds = 10f;
        public float knockbackImpulse = 12f;

        // ========== 未点燃惩罚 ==========
        [Header("Punish ― Full Screen Explosion")]
        public float explosionDrainPerSec = 200f;
        public float explosionDuration = 1.6f;
        public float energyOnPunish = 0f;

        // ========== 二阶段 ==========
        [Header("Phase 2 ― Spin & Dash Chain")]
        public float spinDuration = 7f;
        public Vector2 spinRateDegPerSec = new Vector2(360f, 540f);
        public float spinFireInterval = 0.06f;
        public float spinBulletSpeed = 9f;
        public float spinBulletRedDamage = 10f;

        [Space]
        public int dashCount = 4;
        public float dashSpeed = 22f;
        public float dashPauseSeconds = 1.0f;

        [Header("Phase 2 ― Stylish Specials")]
        public bool enableLotusBloom = true;       // 1/5
        public bool enableOrbitingSparks = true;   // 2/5
        public bool enableStarfallArcs = true;     // 3/5
        public bool enableHomingLaserChase = true; // 4/5 (NEW)
        public bool enableScytheSweep2 = true;     // 5/5 (NEW)

        public int lotusWaves = 6;
        public int lotusPerWave = 24;
        public float lotusWaveAngleOffset = 7.5f;
        public int orbitSparkCount = 8;
        public float orbitRadius = 2.5f;
        public float orbitTime = 2.2f;
        public int starfallArcCount = 10;
        public int starfallArcs = 3;
        public float starfallGravity = 3.2f;

        // ========== 死亡与转场 ==========
        [Header("Death & Scene Transition")]
        public float postDeathDelay = 3f;
        public string storySceneOnDeath = "STORY2";
        public float greenFadeIn = 1.2f;
        public float greenHold = 0.1f;
        public float greenFadeOut = 1.0f;

        // ================== 能量系统 ==================
        [Header("Boss Energy")]
        public float energyMax = 100f;
        public float energyPerCorrectTorch = 50f; // 点燃瞬间爆燃值
        public float energyDecayPerSecond = 0f;
        public Color energyColor = new Color(1f, 0.9f, 0.2f, 1f);

        // === Ambient Heating ===
        [Header("Ambient Heating (持续加热叠条)")]
        public bool enableAmbientHeating = true;
        [Tooltip("当作加热器的层（把火把/灯放在这些层）")]
        public LayerMask heaterLayers;     // 建议只勾 Torch 层
        [Tooltip("在该半径内的光源会给BOSS叠条")]
        public float heatDetectRadius = 9f;
        [Tooltip("光源强度为1、距离为0时，每秒给BOSS的能量")]
        public float heatPerSecondBase = 8f;
        [Tooltip("光源强度小于该阈值时忽略（例如未点燃）")]
        public float minHeaterIntensity = 0.05f;
        [Tooltip("距离权重：rate *= (1 - d/R)^power，power越大衰减越快")]
        public float distanceFalloffPower = 1f;
        [Tooltip("当前“正确火炬”处于燃烧时的额外加热（在物理贡献基础上再加，不想叠加就设为0）")]
        public float currentTorchBonusPerSec = 6f;
        [Tooltip("打印每0.5秒的热源贡献详情")]
        public bool debugHeat = false;

        private readonly Collider2D[] _heatHits = new Collider2D[32];
        private float _nextHeatLogTime;

        // ========== 相机 ==========
        [Header("Camera During Bossfight")]
        public Camera cam;
        public float camSizeMul = 1.25f;

        [Header("Perspective Options")]
        public bool camUseDolly = true;
        public float camBackDistance = 6f;
        public bool camUseFov = false;
        public float camFovMul = 1.15f;
        public float camPerspectiveLerp = 4.5f;

        [Header("Player-First Composition")]
        public bool camUsePlayerFirstCompose = true;
        [Range(0f, 0.45f)] public float camHorizontalMargin01 = 0.18f;
        public float camGuardPullStrength = 1.0f;
        public Vector2 camSoftSizeAtBoss = new Vector2(4.8f, 4.5f);

        [Header("Camera Debug")]
        public bool debugCamera = false;

        private CameraFollow2D _camFollow;
        private float _origCamSize, _origFov;
        private Vector3 _origCamPos, _targetCamPos;
        private Vector2 _origSoftOffset, _origSoftSize;
        private Transform _camAnchor, _origFollowTarget;
        private bool _camModified;

        // ================== HUD ==================
        [Header("Boss HUD")]
        public Vector2 hpBarSize = new Vector2(3.8f, 0.15f);
        public Vector3 hpBarOffset = new Vector3(0, 2.4f, 0);
        public Color hpColorPhase1 = Color.white;
        public Color hpColorPhase2 = new Color(1f, .4f, .2f, 1f);

        public Vector2 energyBarSize = new Vector2(3.8f, 0.12f);
        public Vector3 energyBarOffset = new Vector3(0, 2.15f, 0);

        private LineRenderer _hpBg, _hpFill, _enBg, _enFill;

        // ================== 运行态 ==================
        private enum Phase { Phase1, Phase2, Dead }
        private Phase _phase = Phase.Phase1;

        private int _phase1Hits;
        private int _phase2Hits;

        private bool _busy;
        private BossTorchLink _currentTorch;
        private Coroutine _stateRoutine;

        public bool IsDead { get; private set; }
        private float _energy;

        private Coroutine _trembleCR;

        // Torch 窗口控制
        private bool _windowOpen;
        private bool _windowBreakRequested;
        private bool _lastTorchSuccess;

        // 追击
        [Header("Pursuit (Post-Aggro)")]
        public bool alwaysPursueAfterAggro = true;
        public float pursuitStartDistance = 12f;
        public float pursuitChaseSpeed = 10f;

        // ====== 新增：黑暗精灵波次门控 ======
        [Header("Dark Sprite Wave Control")]
        [Tooltip("开启后：上一波黑暗精灵未清除时，禁止再次召唤新一波")]
        public bool enforceMinionWaveExclusivity = true;
        private readonly List<MinionToken> _activeMinions = new List<MinionToken>();

        // ===== Helpers =====
        private static string PathOf(Transform t)
        {
            if (!t) return "<null>";
            var names = new List<string>();
            for (var cur = t; cur != null; cur = cur.parent) names.Add(cur.name);
            names.Reverse();
            return string.Join("/", names);
        }
        private bool LayerMatch(LayerMask mask, int layer) => (mask.value & (1 << layer)) != 0;

        private void Reset()
        {
            rb = GetComponent<Rigidbody2D>();
        }

        private void Awake()
        {
            if (!rb) rb = GetComponent<Rigidbody2D>();
            
            // 配置Rigidbody2D - BOSS不受重力影响，只通过代码控制移动
            if (rb)
            {
                rb.bodyType = RigidbodyType2D.Kinematic;
                rb.gravityScale = 0f;
                rb.constraints = RigidbodyConstraints2D.FreezeRotation;
            }
            
            if (!player)
            {
                var p = GameObject.FindGameObjectWithTag("Player");
                if (p) player = p.transform;
            }
            if (!cam) cam = Camera.main;
            if (cam)
            {
                _origCamSize = cam.orthographicSize;
                _origFov = cam.fieldOfView;
                _origCamPos = cam.transform.position;
                _targetCamPos = _origCamPos;
                _camFollow = cam.GetComponent<CameraFollow2D>();
                if (_camFollow)
                {
                    _origSoftOffset = _camFollow.softZoneCenterOffset;
                    _origSoftSize = _camFollow.softZoneSize;
                }
            }

            foreach (var t in phase1Torches)
                if (t) t.onIgnited += OnTorchIgnited;
            foreach (var t in phase2Torches)
                if (t) t.onIgnited += OnTorchIgnited;

            BuildBars();
            UpdateBarsVisual();
        }

        private void OnDestroy()
        {
            foreach (var t in phase1Torches)
                if (t) t.onIgnited -= OnTorchIgnited;
            foreach (var t in phase2Torches)
                if (t) t.onIgnited -= OnTorchIgnited;

            TrembleStop();
        }

        private void OnEnable()
        {
            _energy = 0f;
            _aggro = false;
            _nextSpamTime = 0f;
            _nextHeatLogTime = 0f;

            ResolvePlayer(); // 先解析一次

            if (useDetectRadius)
            {
                if (debugLog)
                    Debug.Log($"[BossC2] Detect ON. radius={detectRadius}, usePhysics={usePhysicsCircleCheck}, playerLayerMask={playerLayer.value}", this);
            }
            else if (startAggroImmediately)
            {
                if (debugLog) Debug.Log("[BossC2] StartAggroImmediately -> EnterAggro()", this);
                EnterAggro("ImmediateStart");
            }
        }

        private void OnDisable()
        {
            RestoreCamera();
            TrembleStop();
        }

        private void Update()
        {
            if (!_aggro)
            {
                if (useDetectRadius)
                {
                    if (IsPlayerInDetectStrict())
                    {
                        if (debugLog) Debug.Log("[BossC2] DETECT TRIGGER -> EnterAggro()", this);
                        EnterAggro("Detect");
                    }
                }
                else if (startAggroImmediately)
                {
                    if (debugLog) Debug.Log("[BossC2] Immediate aggro in Update -> EnterAggro()", this);
                    EnterAggro("ImmediateUpdate");
                }
            }

            // —— Ambient Heating：持续加热叠条 ——
            if (enableAmbientHeating && !IsDead)
                TickAmbientHeating();

            if (!_busy && !IsDead && energyDecayPerSecond > 0f && _energy > 0f)
                _energy = Mathf.Max(0f, _energy - energyDecayPerSecond * Time.deltaTime);

            TickCamera();

            if (_aggro && alwaysPursueAfterAggro)
                PursueTick();

            UpdateBarsVisual();

            // Debug spam
            if (debugDetectSpam && Time.time >= _nextSpamTime)
            {
                _nextSpamTime = Time.time + debugDetectSpamInterval;
                SpamDetectSnapshot();
            }
        }

        // ================== 玩家解析（严格版） ==================
        private bool IsLikelyPlayer(Transform t, out string reasonFail)
        {
            reasonFail = null;
            if (!t) { reasonFail = "null"; return false; }
            if (t == transform || t.IsChildOf(transform)) { reasonFail = "is boss child"; return false; }
            if (t.GetComponentInParent<BossTorchLink>() != null) { reasonFail = "is BossTorch"; return false; }
            if (t.GetComponentInParent<Torch>() != null) { reasonFail = "is Torch"; return false; }
            if (t.GetComponentInParent<RedLightController>() == null) { reasonFail = "no RedLightController on parents"; return false; }

            if (requireTagForResolve)
            {
                bool tagOk = t.CompareTag(playerTag) ||
                             (t.root && t.root.CompareTag(playerTag));
                if (!tagOk) { reasonFail = $"tag!=[{playerTag}]"; return false; }
            }
            if (requireLayerForResolve)
            {
                bool layerOk = LayerMatch(playerLayer, t.gameObject.layer) ||
                               LayerMatch(playerLayer, t.root.gameObject.layer);
                if (!layerOk) { reasonFail = $"layer not in mask({playerLayer.value})"; return false; }
            }
            return true;
        }

        private bool ResolvePlayer()
        {
            // 1) Inspector 指定的 player
            if (player)
            {
                string whyNot;
                if (IsLikelyPlayer(player, out whyNot))
                {
                    _playerCol = player.GetComponentInChildren<Collider2D>(true);
                    if (debugLog) Debug.Log($"[BossC2] Player ref ok: {PathOf(player)}  layer={LayerMask.LayerToName(player.gameObject.layer)}", this);
                    return true;
                }
                else if (debugLog)
                {
                    Debug.Log($"[BossC2] Player ref rejected: {PathOf(player)}  reason={whyNot}", this);
                }
            }

            // 2) 优先用 Tag=Player
            GameObject tagged = null;
            try { tagged = GameObject.FindGameObjectWithTag(playerTag); } catch { /* 没这个Tag也行 */ }
            if (tagged)
            {
                string whyNotTag;
                bool ok = IsLikelyPlayer(tagged.transform, out whyNotTag);
                if (ok)
                {
                    player = tagged.transform;
                    _playerCol = player.GetComponentInChildren<Collider2D>(true);
                    if (debugLog) Debug.Log($"[BossC2] Player resolved by tag: {PathOf(player)}  layer={LayerMask.LayerToName(player.gameObject.layer)}", this);
                    return true;
                }
                else if (debugLog)
                {
                    Debug.Log($"[BossC2] Tagged object rejected: {PathOf(tagged.transform)} reason={whyNotTag}", this);
                }
            }

            // 3) 兜底：遍历 RedLightController，但套过滤条件
            var ctrls = FindObjectsOfType<RedLightController>(true);
            Transform best = null; string fail = null;
            foreach (var c in ctrls)
            {
                string whyNot2;
                if (IsLikelyPlayer(c.transform, out whyNot2))
                {
                    best = c.transform; break;
                }
                else fail = whyNot2;
            }
            if (best)
            {
                player = best;
                _playerCol = player.GetComponentInChildren<Collider2D>(true);
                if (debugLog) Debug.Log($"[BossC2] Player resolved by component: {PathOf(player)}  layer={LayerMask.LayerToName(player.gameObject.layer)}", this);
                return true;
            }

            Debug.LogWarning($"[BossC2] ResolvePlayer() FAILED. lastFail={fail}", this);
            player = null; _playerCol = null;
            return false;
        }

        // ================== 检测逻辑（严格） ==================
        private bool IsPlayerInDetectStrict()
        {
            _lastDetectHit = null;
            _lastDetectWhy = null;

            if (!ResolvePlayer()) return false;

            Vector2 pc = _playerCol ? (Vector2)_playerCol.bounds.center : (Vector2)player.position;
            float d2 = ((Vector2)transform.position - pc).sqrMagnitude;
            float r2 = detectRadius * detectRadius;

            if (d2 > r2)
            {
                _lastDetectWhy = $"geo:outside (dist={Mathf.Sqrt(d2):F2})";
                return false;
            }

            if (usePhysicsCircleCheck && playerLayer.value != 0)
            {
                int count = Physics2D.OverlapCircleNonAlloc(transform.position, detectRadius, _hits, playerLayer);
                for (int i = 0; i < count; i++)
                {
                    var h = _hits[i];
                    if (!h) continue;
                    if (h.transform == transform || h.transform.IsChildOf(transform)) continue;
                    if (h.GetComponentInParent<RedLightController>() != null)
                    {
                        _lastDetectHit = h;
                        _lastDetectWhy = $"physics:hit [{h.name}] layer={LayerMask.LayerToName(h.gameObject.layer)} path={PathOf(h.transform)}";
                        return true;
                    }
                }

                bool playerColliderValid = _playerCol && _playerCol.enabled && _playerCol.gameObject.activeInHierarchy;
                if (playerColliderValid)
                {
                    _lastDetectWhy = $"phys:none(block-geo) dist={Mathf.Sqrt(d2):F2} mask={playerLayer.value}";
                    return false;
                }
                else
                {
                    _lastDetectWhy = $"geo:inside(no-phys-hit; player collider disabled) dist={Mathf.Sqrt(d2):F2}";
                    return true;
                }
            }

            _lastDetectWhy = $"geo:inside (dist={Mathf.Sqrt(d2):F2})";
            return true;
        }

        private void SpamDetectSnapshot()
        {
            if (!player) { Debug.Log("[BossC2][Spam] player=null", this); return; }
            Vector2 pc = _playerCol ? (Vector2)_playerCol.bounds.center : (Vector2)player.position;
            float d = Vector2.Distance(transform.position, pc);
            int count = (playerLayer.value != 0) ? Physics2D.OverlapCircleNonAlloc(transform.position, detectRadius, _hits, playerLayer) : 0;
            string phys = (playerLayer.value == 0) ? "mask=Nothing" : (count > 0 ? $"{count} hits" : "no hits");
            Debug.Log($"[BossC2][Spam] d={d:F2}/{detectRadius} phys={phys} lastWhy={_lastDetectWhy} player={PathOf(player)} layer={LayerMask.LayerToName(player.gameObject.layer)}", this);
            if (count > 0)
            {
                for (int i = 0; i < Mathf.Min(count, 6); i++)
                {
                    var h = _hits[i];
                    if (!h) continue;
                    Debug.Log($"   └ hit[{i}] {h.name} layer={LayerMask.LayerToName(h.gameObject.layer)} path={PathOf(h.transform)} pos={h.bounds.center}", this);
                }
            }
        }

        // ================== Torch回调 ==================
        private void OnTorchIgnited(BossTorchLink link)
        {
            if (_currentTorch != null && link == _currentTorch && !_busy && !IsDead)
                StartCoroutine(CoOnTorchSuccess(link));
        }

        private IEnumerator CoOnTorchSuccess(BossTorchLink link)
        {
            _busy = true;

            Vector2 away = ((Vector2)transform.position - (Vector2)link.transform.position).normalized;
            rb.linearVelocity = Vector2.zero; rb.angularVelocity = 0f;
            rb.AddForce(away * Mathf.Min(knockbackImpulse, 6f), ForceMode2D.Impulse);
            yield return new WaitForSeconds(0.06f);
            rb.linearVelocity = Vector2.zero; rb.angularVelocity = 0f;

            if (auraLight) auraLight.intensity *= 1.15f;

            _lastTorchSuccess = true;
            GainEnergy(energyPerCorrectTorch); // 爆燃：瞬间大量加能量
            _windowBreakRequested = true;

            _busy = false;
        }

        // ================== Ambient Heating（持续加热） ==================
        private void TickAmbientHeating()
        {
            float totalPerSec = 0f;
            var lines = debugHeat && Time.time >= _nextHeatLogTime ? new List<string>() : null;

            // 物理圈扫描热源（只在 Heater Layers）
            int n = (heaterLayers.value != 0)
                    ? Physics2D.OverlapCircleNonAlloc(transform.position, heatDetectRadius, _heatHits, heaterLayers)
                    : 0;

            for (int i = 0; i < n; i++)
            {
                var col = _heatHits[i];
                if (!col) continue;
                if (col.transform == transform || col.transform.IsChildOf(transform)) continue;

                // 找 Light2D（自己、子、父都试一下）
                Light2D L = col.GetComponent<Light2D>();
                if (!L) L = col.GetComponentInChildren<Light2D>(true);
                if (!L) L = col.GetComponentInParent<Light2D>(true);
                if (!L || !L.enabled || L.intensity <= minHeaterIntensity) continue;

                // 以光源位置或碰撞体中心估距离
                Vector2 srcPos = (Vector2)(L ? L.transform.position : col.bounds.center);
                float d = Vector2.Distance(transform.position, srcPos);
                float w = Mathf.Pow(Mathf.Clamp01(1f - d / Mathf.Max(0.001f, heatDetectRadius)), Mathf.Max(0.001f, distanceFalloffPower));
                if (w <= 0f) continue;

                float rate = heatPerSecondBase * L.intensity * w; // 每秒贡献
                totalPerSec += rate;

                if (lines != null)
                    lines.Add($" - {col.name} ({LayerMask.LayerToName(col.gameObject.layer)}) I={L.intensity:F2} d={d:F2} w={w:F2} -> +{rate:F2}/s");
            }

            // 当前正确火炬的额外 Bonus（如果它确实在燃烧）
            if (currentTorchBonusPerSec > 0f && _currentTorch != null)
            {
                Light2D torchL = _currentTorch.GetComponentInChildren<Light2D>(true);
                if (torchL && torchL.enabled && torchL.intensity > minHeaterIntensity)
                {
                    Vector2 srcPos = torchL.transform.position;
                    float d = Vector2.Distance(transform.position, srcPos);
                    float w = Mathf.Pow(Mathf.Clamp01(1f - d / Mathf.Max(0.001f, heatDetectRadius)), Mathf.Max(0.001f, distanceFalloffPower));
                    float bonus = currentTorchBonusPerSec * w;
                    totalPerSec += bonus;

                    if (lines != null)
                        lines.Add($" * CurrentTorch bonus I={torchL.intensity:F2} d={d:F2} w={w:F2} -> +{bonus:F2}/s");
                }
            }

            if (totalPerSec > 0f)
                GainEnergy(totalPerSec * Time.deltaTime);

            if (lines != null)
            {
                _nextHeatLogTime = Time.time + 0.5f;
                string sum = totalPerSec.ToString("F2");
                Debug.Log($"[BossC2][Heat] total=+{sum}/s  R={heatDetectRadius}  src={n}\n" + string.Join("\n", lines), this);
            }
        }

        private void GainEnergy(float amount)
        {
            if (IsDead || amount <= 0f) return;
            _energy = Mathf.Min(energyMax, _energy + amount);
            if (_energy >= energyMax - 0.001f) { _energy = 0f; ApplyEnergyHit(); }
        }

        private void ApplyEnergyHit()
        {
            TrembleStop();
            _busy = false;
            _currentTorch = null;

            if (_stateRoutine != null) StopCoroutine(_stateRoutine);

            if (_phase == Phase.Phase1)
            {
                _phase1Hits++;
                _stateRoutine = (_phase1Hits >= phase1HitsToAdvance)
                    ? StartCoroutine(CoPhase2())
                    : StartCoroutine(CoPhase1());
            }
            else if (_phase == Phase.Phase2)
            {
                _phase2Hits++;
                if (_phase2Hits >= phase2HitsToKill) { KillSelf(); return; }
                _stateRoutine = StartCoroutine(CoPhase2());
            }
        }

        // ================== 进入战斗 & 相机 ==================
        private void EnterAggro(string reason = "Unknown")
        {
            if (_aggro) return;
            _aggro = true;

            if (debugLog)
            {
                Debug.Log($"[BossC2][EnterAggro] reason={reason}\n  why={_lastDetectWhy}\n  player={(player ? PathOf(player) : "<null>")} layer={(player ? LayerMask.LayerToName(player.gameObject.layer) : "<null>")}\n  bossPos={transform.position} playerPos={(player ? player.position : Vector3.zero)}", this);
            }

            if (_stateRoutine == null) _stateRoutine = StartCoroutine(CoPhase1());
            ApplyCameraForBossfight();
            CamShake.Instance?.Shake(0.35f, 0.25f);
        }

        private void ApplyCameraForBossfight()
        {
            if (!cam) { Debug.LogWarning("[BossC2][Camera] no Camera reference.", this); return; }

            if (debugCamera)
            {
                Debug.Log($"[BossC2][Camera] Apply start: ortho={cam.orthographic} size={cam.orthographicSize} fov={cam.fieldOfView} pos={cam.transform.position}\n  camFollow={(_camFollow ? _camFollow.name : "<null>")} target={(_camFollow ? PathOf(_camFollow.target) : "<none>")}", this);
            }

            if (cam.orthographic)
            {
                _origCamSize = cam.orthographicSize;
                cam.orthographicSize = _origCamSize * camSizeMul;
            }
            else
            {
                _origFov = cam.fieldOfView;
                _origCamPos = cam.transform.position;
                _targetCamPos = _origCamPos;
                if (camUseDolly) _targetCamPos = _origCamPos - cam.transform.forward * camBackDistance;
                if (camUseFov) cam.fieldOfView = Mathf.Lerp(_origFov, _origFov * camFovMul, 0.5f);
            }
            _camModified = true;

            if (_camFollow && camUsePlayerFirstCompose)
            {
                if (_camAnchor == null)
                {
                    var go = new GameObject("BossC2CamAnchor");
                    _camAnchor = go.transform;
                    _camAnchor.position = player ? player.position : transform.position;
                }
                _origFollowTarget = _camFollow.target;
                _camFollow.target = _camAnchor;
                _camFollow.softZoneSize = camSoftSizeAtBoss;

                if (debugCamera)
                {
                    Debug.Log($"[BossC2][Camera] Set target->Anchor. prevTarget={(_origFollowTarget ? PathOf(_origFollowTarget) : "<null>")}  anchor={_camAnchor.position}  player={(player ? player.position : Vector3.zero)} boss={transform.position}", this);
                    StartCoroutine(CoCameraDebugTrace(1.2f));
                }
            }
        }

        private IEnumerator CoCameraDebugTrace(float dur)
        {
            float t = 0f;
            while (t < dur)
            {
                t += Time.deltaTime;
                if (debugCamera)
                {
                    var tgt = _camFollow ? _camFollow.target : null;
                    Debug.Log($"[BossC2][CameraTrace] camPos={cam.transform.position} ortho={cam.orthographic} size={cam.orthographicSize:F2} fov={cam.fieldOfView:F1}\n  target={(tgt ? PathOf(tgt) : "<null>")} anchor={(_camAnchor ? _camAnchor.position.ToString() : "<null>")} player={(player ? player.position.ToString() : "<null>")} boss={transform.position}", this);
                }
                yield return null;
            }
        }

        private void TickCamera()
        {
            if (!_camModified || !cam) return;

            if (!cam.orthographic)
            {
                if (camUseDolly)
                    cam.transform.position = Vector3.Lerp(cam.transform.position, _targetCamPos, Time.deltaTime * camPerspectiveLerp);
                if (camUseFov)
                    cam.fieldOfView = Mathf.Lerp(cam.fieldOfView, _origFov * camFovMul, Time.deltaTime * camPerspectiveLerp);
            }

            if (_camFollow && camUsePlayerFirstCompose && _camAnchor && player)
            {
                Vector3 p = player.position;
                Vector3 targetAnchor = p;
                Vector3 vp = cam.WorldToViewportPoint(p);

                if (vp.z > 0f)
                {
                    float m = camHorizontalMargin01;
                    Vector3 worldL = cam.ViewportToWorldPoint(new Vector3(m, vp.y, vp.z));
                    Vector3 worldR = cam.ViewportToWorldPoint(new Vector3(1f - m, vp.y, vp.z));

                    if (vp.x < m)
                    {
                        Vector3 delta = worldL - p;
                        targetAnchor = p - delta * camGuardPullStrength;
                    }
                    else if (vp.x > 1f - m)
                    {
                        Vector3 delta = worldR - p;
                        targetAnchor = p - delta * camGuardPullStrength;
                    }
                }

                _camAnchor.position = Vector3.Lerp(_camAnchor.position, targetAnchor, Time.deltaTime * 10f);
                _camFollow.softZoneCenterOffset = Vector2.Lerp(_camFollow.softZoneCenterOffset, Vector2.zero, Time.deltaTime * 5f);
            }
        }

        private void RestoreCamera()
        {
            if (!cam) return;

            if (debugCamera)
                Debug.Log($"[BossC2][Camera] Restore begin. camFollow={(_camFollow ? _camFollow.name : "<null>")} target={(_camFollow ? PathOf(_camFollow.target) : "<none>")}", this);

            if (cam.orthographic) cam.orthographicSize = _origCamSize;
            else { if (camUseFov) cam.fieldOfView = _origFov; if (camUseDolly) cam.transform.position = _origCamPos; }

            if (_camFollow)
            {
                if (camUsePlayerFirstCompose)
                {
                    _camFollow.target = _origFollowTarget;
                    if (_camAnchor) Destroy(_camAnchor.gameObject);
                    _camAnchor = null;
                }
                _camFollow.softZoneCenterOffset = _origSoftOffset;
                _camFollow.softZoneSize = _origSoftSize;
            }
            _camModified = false;

            if (debugCamera)
                Debug.Log($"[BossC2][Camera] Restore done. target={(_camFollow ? PathOf(_camFollow.target) : "<none>")} camPos={cam.transform.position}", this);
        }

        // ================== Phase 1 ==================
        private IEnumerator CoPhase1()
        {
            _phase = Phase.Phase1;
            _busy = true;
            _currentTorch = null;

            float hoverY1 = (player ? player.position.y : transform.position.y) + 6f;
            yield return MoveToHoverY(hoverY1, 9f);

            for (int i = 0; i < 3; i++)
            {
                int pick = Random.Range(0, 5); // 0..4 (新增2个技能)
                if (pick == 0) yield return DoAirVolley();
                else if (pick == 1) yield return DoAirGrenade();
                else if (pick == 2)   // 召唤，带波次门控
                {
                    if (CanSpawnMinionWave()) yield return DoAirSummon();
                    else yield return DoAirVolley(); // 无法召唤则替换为其他攻击
                }
                else if (pick == 3) yield return CoHomingLaser(homingLaserDurationP1, homingLaserDrainPerSecP1, homingLaserTurnRateDegP1, laserColorP1, laserWidthP1);
                else yield return CoScytheSweep(scytheSweepSpanDegP1, scytheSweepSecondsP1, scytheSweepDrainPerSecP1, laserColorP1, laserWidthP1);

                yield return new WaitForSeconds(Random.Range(attackIntervalRange.x, attackIntervalRange.y));
            }

            // 收集有效的点位索引
            var validIndices = new List<int>();
            for (int i = 0; i < 4; i++)
            {
                if (phase1DropPoints[i] != null)
                {
                    validIndices.Add(i);
                }
            }

            // 如果没有有效点位，记录警告并跳过此阶段
            if (validIndices.Count == 0)
            {
                Debug.LogWarning("[BossC2] Phase1: 没有有效的DropPoints，跳过落点阶段！", this);
                yield break;
            }

            // 从有效点位中随机选择一个作为真实BOSS落点
            int realIdx = validIndices[Random.Range(0, validIndices.Count)];
            var clones = new List<BossC2Clone>(3);
            
            for (int i = 0; i < 4; i++)
            {
                if (!phase1DropPoints[i]) continue;

                if (i == realIdx)
                {
                    yield return MoveToPoint(phase1DropPoints[i].position, 10f);
                    TrembleStart();
                }
                else
                {
                    if (clonePrefab)
                    {
                        var c = Instantiate(clonePrefab, transform.position, Quaternion.identity);
                        c.SpawnTo(phase1DropPoints[i].position, tremble: true, lifeSeconds: torchWindowSeconds);
                        clones.Add(c);
                    }
                }
            }

            _currentTorch = phase1Torches[realIdx];
            _lastTorchSuccess = false;
            _windowBreakRequested = false;
            _windowOpen = true;
            _busy = false;

            float t = 0f;
            while (_windowOpen && !_windowBreakRequested && t < torchWindowSeconds && !IsDead && _phase == Phase.Phase1)
            {
                t += Time.deltaTime;
                yield return null;
            }
            _windowOpen = false;
            _busy = true;

            TrembleStop();
            foreach (var c in clones) if (c) c.ForceVanish();

            if (_phase != Phase.Phase1 || IsDead) yield break;

            if (_lastTorchSuccess)
            {
                _stateRoutine = StartCoroutine(CoPhase1());
                yield break;
            }

            yield return DoFullScreenExplosion();
            if (energyOnPunish > 0f) GainEnergy(energyOnPunish);
            if (!IsDead) _stateRoutine = StartCoroutine(CoPhase1());

            _busy = false;
        }

        private IEnumerator DoAirVolley()
        {
            if (!player || !bulletPrefab) yield break;
            for (int k = 0; k < bigBulletVolley; k++)
            {
                var b = Instantiate(bulletPrefab, transform.position, Quaternion.identity);
                b.redDamage = bigBulletRedDamage;
                b.speed = bigBulletSpeed;
                Vector2 dir = ((Vector2)player.position - (Vector2)transform.position).normalized;
                b.Fire(dir);
                yield return new WaitForSeconds(0.08f);
            }
        }

        private IEnumerator DoAirGrenade()
        {
            if (!player || !grenadePrefab) yield break;
            var g = Instantiate(grenadePrefab, transform.position, Quaternion.identity);
            g.speed = grenadeSpeed;
            Vector2 dir = ((Vector2)player.position - (Vector2)transform.position).normalized;
            g.Fire(dir);
            yield return null;
        }

        private IEnumerator DoAirSummon()
        {
            if (!darkSpritePrefab) yield break;
            if (enforceMinionWaveExclusivity && _activeMinions.Count > 0) yield break;

            int n = Random.Range(2, 5);
            for (int i = 0; i < n; i++)
            {
                var d = Instantiate(darkSpritePrefab, transform.position + (Vector3)Random.insideUnitCircle * 1.2f, Quaternion.identity);
                d.player = player;

                // 给每个 minion 绑一个 Token，销毁时回报 Boss
                var token = d.gameObject.AddComponent<MinionToken>();
                token.Bind(this);
                _activeMinions.Add(token);

                yield return new WaitForSeconds(0.05f);
            }

            // 可选：如果你希望当前这一波必须清完才继续其他攻击，可在这里等待：
            // yield return WaitForAllMinionsDead();
        }

        // ================== Phase 2 ==================
        private IEnumerator CoPhase2()
        {
            _phase = Phase.Phase2;
            _busy = true;
            _currentTorch = null;

            if (auraLight) auraLight.intensity *= 1.2f;
            float hoverY2 = (player ? player.position.y : transform.position.y) + 5.5f;
            yield return MoveToHoverY(hoverY2, 9f);

            yield return CoSpinShoot(spinDuration);

            // 收集有效的第二阶段点位索引
            var validP2Indices = new List<int>();
            for (int i = 0; i < 4; i++)
            {
                if (phase2DashPoints[i] != null)
                {
                    validP2Indices.Add(i);
                }
            }

            // 如果没有有效点位，记录警告并跳过冲刺阶段
            if (validP2Indices.Count == 0)
            {
                Debug.LogWarning("[BossC2] Phase2: 没有有效的DashPoints，跳过冲刺阶段！", this);
                _currentTorch = null;
                _busy = false;
                yield break;
            }

            int last = -1;
            for (int i = 0; i < dashCount; i++)
            {
                int pick = validP2Indices[Random.Range(0, validP2Indices.Count)];
                if (pick == last && validP2Indices.Count > 1)
                {
                    // 避免连续两次选同一个点位（如果有多个点位的话）
                    pick = validP2Indices[Random.Range(0, validP2Indices.Count)];
                }
                last = pick;

                if (phase2DashPoints[pick])
                    yield return MoveToPoint(phase2DashPoints[pick].position, dashSpeed);
                yield return new WaitForSeconds(dashPauseSeconds);
            }

            int stay = (last >= 0) ? last : validP2Indices[Random.Range(0, validP2Indices.Count)];
            if (phase2DashPoints[stay])
                yield return MoveToPoint(phase2DashPoints[stay].position + (Vector3)Random.insideUnitCircle * 0.5f, dashSpeed);

            yield return CoPickOneSpecial();

            _currentTorch = phase2Torches[stay];

            _lastTorchSuccess = false;
            _windowBreakRequested = false;
            _windowOpen = true;
            _busy = false;

            float t = 0f;
            while (_windowOpen && !_windowBreakRequested && t < torchWindowSeconds && !IsDead && _phase == Phase.Phase2)
            {
                t += Time.deltaTime;
                yield return null;
            }
            _windowOpen = false;
            _busy = true;

            if (_phase != Phase.Phase2 || IsDead) yield break;

            if (_lastTorchSuccess)
            {
                _stateRoutine = StartCoroutine(CoPhase2());
                yield break;
            }

            yield return DoFullScreenExplosion();
            if (energyOnPunish > 0f) GainEnergy(energyOnPunish);
            if (!IsDead) _stateRoutine = StartCoroutine(CoPhase2());

            _busy = false;
        }

        private IEnumerator CoSpinShoot(float dur)
        {
            if (!bulletPrefab) yield break;

            float timer = 0f;
            float rate = Random.Range(spinRateDegPerSec.x, spinRateDegPerSec.y);
            float nextFire = 0f;

            while (timer < dur)
            {
                timer += Time.deltaTime;
                transform.rotation = Quaternion.Euler(0, 0, transform.eulerAngles.z + rate * Time.deltaTime);

                nextFire -= Time.deltaTime;
                if (nextFire <= 0f)
                {
                    var b = Instantiate(bulletPrefab, transform.position, Quaternion.identity);
                    float ang = Random.Range(0f, 360f) * Mathf.Deg2Rad;
                    Vector2 dir = new Vector2(Mathf.Cos(ang), Mathf.Sin(ang));
                    b.redDamage = spinBulletRedDamage;
                    b.speed = spinBulletSpeed;
                    b.Fire(dir);
                    nextFire = spinFireInterval;
                }
                yield return null;
            }
            transform.rotation = Quaternion.identity;
        }

        private IEnumerator CoPickOneSpecial()
        {
            var list = new List<System.Func<IEnumerator>>();
            if (enableLotusBloom) list.Add(CoLotusBloom);
            if (enableOrbitingSparks) list.Add(CoOrbitingSparks);
            if (enableStarfallArcs) list.Add(CoStarfallArcs);
            if (enableHomingLaserChase) list.Add(() => CoHomingLaser(homingLaserDurationP2, homingLaserDrainPerSecP2, homingLaserTurnRateDegP2, laserColorP2, laserWidthP2));
            if (enableScytheSweep2) list.Add(() => CoScytheSweep(scytheSweepSpanDegP2, scytheSweepSecondsP2, scytheSweepDrainPerSecP2, laserColorP2, laserWidthP2));
            if (list.Count == 0) yield break;

            int pick = Random.Range(0, list.Count);
            yield return StartCoroutine(list[pick]());
        }

        private IEnumerator CoLotusBloom()
        {
            if (!bulletPrefab) yield break;
            for (int w = 0; w < lotusWaves; w++)
            {
                float baseAngle = (w * lotusWaveAngleOffset) * Mathf.Deg2Rad;
                for (int i = 0; i < lotusPerWave; i++)
                {
                    float t = (i / (float)lotusPerWave) * Mathf.PI * 2f + baseAngle;
                    Vector2 dir = new Vector2(Mathf.Cos(t), Mathf.Sin(t));
                    var b = Instantiate(bulletPrefab, transform.position, Quaternion.identity);
                    b.redDamage = spinBulletRedDamage;
                    b.speed = spinBulletSpeed * Mathf.Lerp(0.8f, 1.25f, (i % 2 == 0) ? 1f : 0f);
                    b.Fire(dir);
                }
                yield return new WaitForSeconds(0.18f);
            }
        }

        private IEnumerator CoOrbitingSparks()
        {
            if (!bulletPrefab) yield break;

            var sparks = new List<BossRedDrainBullet>();
            for (int i = 0; i < orbitSparkCount; i++)
            {
                var s = Instantiate(bulletPrefab, transform.position, Quaternion.identity);
                s.redDamage = Mathf.Max(6f, spinBulletRedDamage * 0.6f);
                s.speed = 0f;
                s.locked = true;
                sparks.Add(s);
            }

            float timer = 0f;
            while (timer < orbitTime)
            {
                timer += Time.deltaTime;
                for (int i = 0; i < sparks.Count; i++)
                {
                    float t = (i / (float)sparks.Count) * Mathf.PI * 2f + timer * 2.5f;
                    Vector3 pos = transform.position + new Vector3(Mathf.Cos(t), Mathf.Sin(t), 0f) * orbitRadius;
                    if (sparks[i]) sparks[i].transform.position = pos;
                }
                yield return null;
            }

            foreach (var s in sparks)
            {
                if (!s) continue;
                Vector2 dir = ((Vector2)s.transform.position - (Vector2)transform.position).normalized;
                s.locked = false;
                s.speed = spinBulletSpeed * 1.2f;
                s.Fire(dir);
            }
            yield return new WaitForSeconds(0.4f);
        }

        private IEnumerator CoStarfallArcs()
        {
            if (!bulletPrefab) yield break;
            for (int a = 0; a < starfallArcs; a++)
            {
                float baseAng = Random.Range(-30f, 30f) * Mathf.Deg2Rad;
                for (int i = 0; i < starfallArcCount; i++)
                {
                    float t = baseAng + Mathf.Lerp(-0.6f, 0.6f, i / (float)(starfallArcCount - 1));
                    var b = Instantiate(bulletPrefab, transform.position + Vector3.up * 0.6f, Quaternion.identity);
                    b.redDamage = Mathf.Max(8f, spinBulletRedDamage * 0.8f);
                    b.speed = spinBulletSpeed * 0.9f;
                    b.gravity = 3.2f;
                    Vector2 dir = new Vector2(Mathf.Cos(t), Mathf.Sin(t));
                    b.Fire(dir);
                }
                yield return new WaitForSeconds(0.18f);
            }
        }

        // ================== 追击 ==================
        private void PursueTick()
        {
            if (!player || IsDead) return;
            if (_busy || _windowOpen) return;

            float dist = Vector2.Distance(player.position, transform.position);
            if (dist > pursuitStartDistance)
            {
                float hover = (player ? player.position.y : transform.position.y) + ((_phase == Phase.Phase1) ? 6f : 5.5f);
                Vector3 target = new Vector3(player.position.x, hover, transform.position.z);
                Vector3 next = Vector3.MoveTowards(transform.position, target, pursuitChaseSpeed * Time.deltaTime);
                rb.MovePosition(next);
            }
        }

        // ================== 激光技能（公共实现） ==================
        private IEnumerator CoHomingLaser(float duration, float drainPerSec, float turnRateDeg, Color color, float width)
        {
            if (!ResolvePlayer()) yield break;

            // 构建LR
            var lr = CreateLaserLR(color, width, out Material tmpMat);
            GameObject hitFx = null;
            if (laserHitGroundVfx) hitFx = Instantiate(laserHitGroundVfx);

            Vector2 dir = (player.position - transform.position).normalized;
            float t = 0f;
            while (t < duration && !IsDead)
            {
                t += Time.deltaTime;

                // 转向玩家（限定角速度）
                if (player)
                {
                    Vector2 desired = ((Vector2)player.position - (Vector2)transform.position).normalized;
                    dir = Vector2RotateTowards(dir, desired, turnRateDeg * Mathf.Deg2Rad * Time.deltaTime);
                }

                // 计算终点：优先地面遮挡
                float dist = laserMaxDistance;
                RaycastHit2D hitG = Physics2D.Raycast(transform.position, dir, laserMaxDistance, groundMask);
                if (hitG.collider) dist = hitG.distance;
                Vector3 a = transform.position;
                Vector3 b = a + (Vector3)(dir * dist);

                // 玩家命中检测（只在终点之前）
                bool hitPlayer = false;
                if (playerLayer.value != 0)
                {
                    var hitP = Physics2D.Raycast(a, dir, dist, playerLayer);
                    hitPlayer = hitP.collider && hitP.collider.GetComponentInParent<RedLightController>() != null;
                }
                if (hitPlayer && laserContinuousDrain)
                {
                    var r = player ? player.GetComponentInParent<RedLightController>() : null;
                    r?.TryConsume(drainPerSec * Time.deltaTime);
                }

                // 更新激光与地面VFX位置
                lr.SetPosition(0, a);
                lr.SetPosition(1, b);
                if (hitFx) hitFx.transform.position = b;

                if (t == 0f) CamShake.Instance?.Shake(0.15f, 0.18f);
                yield return null;
            }

            // 淡出
            yield return FadeOutAndDisposeLaser(lr, hitFx, tmpMat);
        }

        private IEnumerator CoScytheSweep(float spanDeg, float seconds, float drainPerSec, Color color, float width)
        {
            if (!ResolvePlayer()) yield break;

            var lr = CreateLaserLR(color, width, out Material tmpMat);
            GameObject hitFx = null;
            if (laserHitGroundVfx) hitFx = Instantiate(laserHitGroundVfx);

            // 从面向玩家的方向开始，向左右随机一个方向横扫 spanDeg
            Vector2 baseDir = (player.position - transform.position).normalized;
            float half = spanDeg * 0.5f;
            float start = Random.value < 0.5f ? -half : +half;
            float end = -start;
            float timer = 0f;

            while (timer < seconds && !IsDead)
            {
                timer += Time.deltaTime;
                float u = Mathf.Clamp01(timer / Mathf.Max(0.0001f, seconds));
                float currentDeg = Mathf.Lerp(start, end, EaseOutCubic(u));
                Vector2 dir = Quaternion.Euler(0, 0, currentDeg) * baseDir;

                float dist = laserMaxDistance;
                var hitG = Physics2D.Raycast(transform.position, dir, laserMaxDistance, groundMask);
                if (hitG.collider) dist = hitG.distance;
                Vector3 a = transform.position;
                Vector3 b = a + (Vector3)(dir * dist);

                bool hitPlayer = false;
                if (playerLayer.value != 0)
                {
                    var hitP = Physics2D.Raycast(a, dir, dist, playerLayer);
                    hitPlayer = hitP.collider && hitP.collider.GetComponentInParent<RedLightController>() != null;
                }
                if (hitPlayer && laserContinuousDrain)
                {
                    var r = player ? player.GetComponentInParent<RedLightController>() : null;
                    r?.TryConsume(drainPerSec * Time.deltaTime);
                }

                lr.SetPosition(0, a);
                lr.SetPosition(1, b);
                if (hitFx) hitFx.transform.position = b;

                yield return null;
            }

            CamShake.Instance?.Shake(0.18f, 0.22f);
            yield return FadeOutAndDisposeLaser(lr, hitFx, tmpMat);
        }

        private LineRenderer CreateLaserLR(Color c, float width, out Material tmpMat)
        {
            tmpMat = null;
            var go = new GameObject("BossLaserLR");
            go.transform.SetParent(null); // 世界空间
            var lr = go.AddComponent<LineRenderer>();
            lr.useWorldSpace = true;
            lr.positionCount = 2;
            lr.numCapVertices = 10;
            lr.numCornerVertices = 4;
            lr.sortingOrder = 12000;
            lr.startWidth = lr.endWidth = width;

            Material m = laserMaterial;
            if (!m)
            {
                m = new Material(Shader.Find("Universal Render Pipeline/Unlit"));
                tmpMat = m; // 稍后销毁
            }
            if (m.HasProperty("_BaseColor")) m.SetColor("_BaseColor", c);
            lr.material = m;
            return lr;
        }

        private IEnumerator FadeOutAndDisposeLaser(LineRenderer lr, GameObject hitFx, Material tmpMat)
        {
            float t = 0f;
            float startW = lr.startWidth;
            Color c = lr.material.HasProperty("_BaseColor") ? lr.material.GetColor("_BaseColor") : Color.white;

            while (t < laserFadeOutSeconds)
            {
                t += Time.deltaTime;
                float u = 1f - Mathf.Clamp01(t / Mathf.Max(0.0001f, laserFadeOutSeconds));
                float w = Mathf.Lerp(0.02f, startW, u);
                lr.startWidth = lr.endWidth = w;
                if (lr.material.HasProperty("_BaseColor"))
                {
                    Color cc = c; cc.a = Mathf.Lerp(0f, c.a, u);
                    lr.material.SetColor("_BaseColor", cc);
                }
                yield return null;
            }

            if (hitFx) Destroy(hitFx);
            if (lr) Destroy(lr.gameObject);
            if (tmpMat) Destroy(tmpMat);
        }

        private static float EaseOutCubic(float x) => 1 - Mathf.Pow(1 - x, 3);

        private static Vector2 Vector2RotateTowards(Vector2 from, Vector2 to, float maxRadiansDelta)
        {
            float angle = Vector2.SignedAngle(from, to) * Mathf.Deg2Rad;
            float clamped = Mathf.Clamp(angle, -maxRadiansDelta, maxRadiansDelta);
            return (Quaternion.Euler(0, 0, clamped * Mathf.Rad2Deg) * from).normalized;
        }

        // ================== 通用动作 ==================
        private IEnumerator MoveToPoint(Vector3 target, float speed)
        {
            while ((transform.position - target).sqrMagnitude > 0.02f)
            {
                Vector3 next = Vector3.MoveTowards(transform.position, target, speed * Time.deltaTime);
                rb.MovePosition(next);
                yield return null;
            }
        }
        private IEnumerator MoveToHoverY(float targetY, float speed)
        {
            Vector3 target = new Vector3(transform.position.x, targetY, transform.position.z);
            yield return MoveToPoint(target, speed);
        }

        // --- 抖动 ---
        private void TrembleStart(float amp = 0.12f)
        {
            TrembleStop();
            _trembleCR = StartCoroutine(CoTremble(amp));
        }

        private void TrembleStop()
        {
            if (_trembleCR != null) { StopCoroutine(_trembleCR); _trembleCR = null; }
            if (model) model.transform.localPosition = Vector3.zero;
        }

        private IEnumerator CoTremble(float amp)
        {
            float t = 0f;
            while (true)
            {
                t += Time.deltaTime * 28f;
                Vector2 n = new Vector2(Mathf.Sin(t), Mathf.Cos(t * 0.9f)) * amp;
                if (model) model.transform.localPosition = n;
                yield return null;
            }
        }

        private IEnumerator DoFullScreenExplosion()
        {
            if (bigExplosionVfx) Instantiate(bigExplosionVfx, transform.position, Quaternion.identity);

            var r = player ? player.GetComponentInParent<RedLightController>() : null;
            float t = 0f;
            while (t < explosionDuration)
            {
                if (r) r.TryConsume(explosionDrainPerSec * Time.deltaTime);
                t += Time.deltaTime;
                yield return null;
            }
        }

        // ================== 黑暗精灵门控工具 ==================
        private bool CanSpawnMinionWave() => !enforceMinionWaveExclusivity || _activeMinions.Count == 0;

        private IEnumerator WaitForAllMinionsDead()
        {
            while (_activeMinions.Count > 0) yield return null;
        }

        private void OnMinionDestroyed(MinionToken tok)
        {
            _activeMinions.Remove(tok);
        }

        private class MinionToken : MonoBehaviour
        {
            private BossChapter2Controller _owner;
            public void Bind(BossChapter2Controller owner) => _owner = owner;
            private void OnDestroy() { if (_owner) _owner.OnMinionDestroyed(this); }
        }

        // ================== IDamageable ==================
        public void TakeDamage(float amount) { /* 统一走能量条满 */ }

        private void KillSelf()
        {
            if (IsDead) return;
            IsDead = true;
            _phase = Phase.Dead;

            if (deathVfxPrefab) Instantiate(deathVfxPrefab, transform.position, Quaternion.identity);
            ToggleBars(false);
            StartCoroutine(CoDeathTransition());
        }

        private IEnumerator CoDeathTransition()
        {
            yield return new WaitForSeconds(postDeathDelay);
            GreenCurtainSimple.Go(storySceneOnDeath, greenFadeIn, greenHold, greenFadeOut);
            RestoreCamera();
        }

        // ================== HUD ==================
        private void BuildBars()
        {
            GameObject root = new GameObject("BossHPBar");
            root.transform.SetParent(transform, false);

            _hpBg = root.AddComponent<LineRenderer>();
            SetupLR(_hpBg, 9999, new Color(0, 0, 0, 0.5f), hpBarSize.y);

            GameObject fg = new GameObject("Fill");
            fg.transform.SetParent(root.transform, false);
            _hpFill = fg.AddComponent<LineRenderer>();
            SetupLR(_hpFill, 10000, hpColorPhase1, hpBarSize.y * 1.15f);

            GameObject eroot = new GameObject("BossEnergyBar");
            eroot.transform.SetParent(transform, false);

            _enBg = eroot.AddComponent<LineRenderer>();
            SetupLR(_enBg, 9998, new Color(0, 0, 0, 0.45f), energyBarSize.y);

            GameObject efg = new GameObject("Fill");
            efg.transform.SetParent(eroot.transform, false);
            _enFill = efg.AddComponent<LineRenderer>();
            SetupLR(_enFill, 10001, energyColor, energyBarSize.y * 1.1f);
        }

        private void SetupLR(LineRenderer lr, int order, Color c, float width)
        {
            lr.useWorldSpace = true;
            lr.positionCount = 2;
            lr.numCapVertices = 6;
            lr.numCornerVertices = 2;
            lr.sortingOrder = order;

            var mat = new Material(Shader.Find("Universal Render Pipeline/Unlit"));
            if (mat.HasProperty("_BaseColor")) mat.SetColor("_BaseColor", c);
            lr.material = mat;

            lr.startWidth = lr.endWidth = width;
        }

        private void ToggleBars(bool v)
        {
            if (_hpBg) _hpBg.enabled = v;
            if (_hpFill) _hpFill.enabled = v;
            if (_enBg) _enBg.enabled = v;
            if (_enFill) _enFill.enabled = v;
        }

        private void UpdateBarsVisual()
        {
            if (_hpBg != null && _hpFill != null)
            {
                Vector3 center = transform.position + hpBarOffset;
                float half = hpBarSize.x * 0.5f;
                Vector3 left = center + new Vector3(-half, 0, 0);
                Vector3 right = center + new Vector3(+half, 0, 0);

                _hpBg.SetPosition(0, left);
                _hpBg.SetPosition(1, right);

                int total = (_phase == Phase.Phase1) ? phase1HitsToAdvance :
                            (_phase == Phase.Phase2 ? phase2HitsToKill : 1);
                int done = (_phase == Phase.Phase1) ? _phase1Hits :
                           (_phase == Phase.Phase2 ? _phase2Hits : 1);
                float ratio = total <= 0 ? 0f : Mathf.Clamp01(1f - (done / (float)total));

                Vector3 fillRight = Vector3.Lerp(left, right, ratio);
                _hpFill.SetPosition(0, left);
                _hpFill.SetPosition(1, fillRight);

                Color c = (_phase == Phase.Phase1) ? hpColorPhase1 : hpColorPhase2;
                if (_hpFill.material && _hpFill.material.HasProperty("_BaseColor"))
                    _hpFill.material.SetColor("_BaseColor", c);
            }

            if (_enBg != null && _enFill != null)
            {
                Vector3 center = transform.position + energyBarOffset;
                float half = energyBarSize.x * 0.5f;
                Vector3 left = center + new Vector3(-half, 0, 0);
                Vector3 right = center + new Vector3(+half, 0, 0);

                _enBg.SetPosition(0, left);
                _enBg.SetPosition(1, right);

                float ratio = energyMax <= 0f ? 0f : Mathf.Clamp01(_energy / energyMax);
                Vector3 fillRight = Vector3.Lerp(left, right, ratio);
                _enFill.SetPosition(0, left);
                _enFill.SetPosition(1, fillRight);
            }
        }

        // ================== Debug / Utilities ==================
        [ContextMenu("Force Aggro Now")]
        public void ForceAggroNow()
        {
            if (debugLog) Debug.Log("[BossC2] ForceAggroNow()", this);
            EnterAggro("ContextMenu");
        }

        private void OnValidate()
        {
            if (detectRadius < 0.5f) detectRadius = 0.5f;
            if (camHorizontalMargin01 < 0f) camHorizontalMargin01 = 0f;
            if (camHorizontalMargin01 > 0.45f) camHorizontalMargin01 = 0.45f;
        }

        // ================== Gizmos ==================
        private void OnDrawGizmosSelected()
        {
            if (useDetectRadius)
            {
                Gizmos.color = new Color(1f, 0f, 0f, 0.25f);
                Gizmos.DrawWireSphere(transform.position, detectRadius);
            }
            if (enableAmbientHeating)
            {
                Gizmos.color = new Color(1f, 0.8f, 0.2f, 0.22f);
                Gizmos.DrawWireSphere(transform.position, heatDetectRadius);
            }
        }
    }
}
